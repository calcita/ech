<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Estimación de ingresos</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Estimación de ingresos</h1>



<p>La medición de los ingresos tiene un rezago de un mes ya que si el
hogar fue encuestado, por ejemplo en marzo, en este mes se preguntó por
los ingresos del mes pasado, es decir de febrero. A su vez, estos
ingresos están expresados a precios corrientes, por lo cual, para
hacerlos comparables entre los diferentes meses de la encuesta o de
otros años es necesario llevarlos a una medida común. Para convertir los
ingresos de precios corrientes a precios constantes debemos elegir un
índice como puede ser el IPC (Índice de Precios al Consumo) o el IPAB
(Índice de Precios de Alimentos y Bebidas) para construir un deflactor.
Por ejemplo, para expresar los ingresos del hogar con la información de
la ECH 2019, elegimos como mes base junio y como año base 2019 y como
deflactor el IPC. Esto implica que debemos considerar los valores del
IPC mensual desde diciembre 2018 a noviembre 2019.</p>
<p>Obtener los datos del IPC es bastante sencillo usando el paquete
<code>ech</code>, para ello existe la fucnión de hecho la función
<code>get_ipc()</code> que descarga el archivo de la web del INE y lo
guarda en un formato tidy en el data frame <code>ipc_base2010</code>. La
estructura del objeto es la siguiente:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span>(ech<span class="sc">::</span>ipc_base2010)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; # A tibble: 6 x 8</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   fecha      indice             mensual  acum_~1 acum_~2 trime~3 cuatr~4 semes~5</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   &lt;date&gt;     &lt;chr&gt;              &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  </span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1 2022-03-01 250.41999999999999 1.11000~ 4.4199~ 9.3800~ 4.4243~ 4.3199~ 5.6713~</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2 2022-04-01 251.65000000000001 0.48999~ 4.9400~ 9.3699~ 3.0972~ 4.9372~ 5.0993~</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3 2022-05-01 252.81999999999999 0.46000~ 5.4299~ 9.3699~ 2.0752~ 3.5765~ 5.3197~</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 4 2022-06-01 254.30000000000001 0.58999~ 6.04    9.2899~ 1.5493~ 2.6728~ 6.0422~</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 5 2022-07-01 256.25999999999999 0.77000~ 6.8600~ 9.5600~ 1.8319~ 2.3320~ 4.9858~</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 6 2022-08-01 258.38             0.82999~ 7.7400~ 9.5299~ 2.1991~ 2.6743~ 4.3200~</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; # ... with abbreviated variable names 1: acum_ano, 2: acum_12_meses,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; #   3: trimestre, 4: cuatrimestre, 5: semestre</span></span></code></pre></div>
<p>La función que permite obtener un deflactor es la función deflate(),
que a su vez, utiliza internamente la función <code>get_ipc()</code>. No
utilizamos directamente ninguna de estas funciones, sino que la
simplicidad de ech radica en que para calcular ingresos a precios
constantes usamos la función <code>income_constant_prices()</code> la
cual utiliza internamente las otras dos funciones ya mencionadas.</p>
<p>Antes de deflactar los ingresos del hogar, tenemos que tener cargado
el objeto con los microdatos de la ECH.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ech)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">get_microdata</span>(<span class="at">year =</span> <span class="dv">2019</span>, <span class="at">folder =</span> <span class="fu">tempdir</span>(), <span class="at">toR =</span> <span class="cn">FALSE</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">#df &lt;- organize_names(df)</span></span></code></pre></div>
<p>Las variables a tener en cuenta en esta parte son:</p>
<ul>
<li><code>ht11</code>: Ingreso total del hogar con valor locativo sin
servicio doméstico</li>
<li><code>ht13</code>: Valor locativo</li>
<li><code>ht19</code>: Cantidad de personas sin servicio doméstico</li>
<li><code>numero</code>: Identificador del hogar</li>
</ul>
<p>Para convertir los ingresos del hogar, que están medidos en la
variable <code>ht11</code>, de precios corrientes a precios constantes,
usamos la función <code>income_constant_prices()</code> y definimos sus
parámetros: mes base (<code>base_month</code>), año base
(<code>base_year</code>), el tipo de índice (<code>index</code>) que
puede IPC o IPAB y el nivel del índice (<code>level</code>) que puede
ser “G” (general) o “R” (regional que distingue entre Montevideo e
Interior). Definimos como base enero de 2005.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">income_constant_prices</span>(<span class="at">data =</span> df, <span class="at">base_month =</span> <span class="dv">1</span>, <span class="at">base_year =</span> <span class="dv">2005</span>, <span class="at">index =</span> <span class="st">&quot;IPC&quot;</span>, <span class="at">level =</span> <span class="st">&quot;G&quot;</span>)</span></code></pre></div>
<p>Esto crea una serie de variables:</p>
<ul>
<li><code>y_pc</code>: ingreso per cápita a precios corrientes</li>
<li><code>y_pc_d</code>: ingreso per cápita a precios constantes</li>
<li><code>rv_d</code>: valor locativo a precios constantes</li>
<li><code>y_wrv_d</code>: ingreso sin valor locativo a precios
constantes</li>
<li><code>y_wrv_pc_d</code>: ingreso sin valor locativo per cápita a
precios constantes</li>
</ul>
<p>Para obtener la estimación de alguna de estas variables usamos la
función <code>get_estimation_mean()</code>, para estimar la media,
<code>get_estimation_total()</code>, para estimar el total o
<code>get_estimation_median()</code> para estimar la mediana. Estas
funciones tienen algunos argumentos que refieren al diseño de muestreo
como:</p>
<ul>
<li><code>numero</code>: se debe indicar la variable que identifica a
los hogares</li>
<li><code>pesoano</code>: se debe indicar la variable uqe identifica los
pesos asociados a cada hogar.</li>
<li><code>ids</code>: se debe indicar la variable que identifica a la
unidades primarias de muestreo.</li>
<li><code>estrato</code>: se debe indicar la variable que identifica a
los estratos.</li>
</ul>
<p>Para los microdatos de 2018 y 2019 la ECH pública cuenta con la
información de las UPM y estratos. En la web del INE se encuentra en un
archivo aparte pero la función <code>get_microdata()</code> ya la agrega
a los microdatos que genera de manera que no es necesario hacer un merge
entre ambas bases. Para años anteriores no están disponible estás
variables en la base pública.</p>
<p>Es necesario definir <code>ids</code> y <code>estrato</code> que
vienen con valor por defecto NULL, las demás se pueden dejar con sus
valores por defecto, salvo que se usen registros de un mes o semestre en
ese caso se debe cambiar el ponderador de los casos según
corresponda.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">get_estimation_mean</span>(df, <span class="at">variable =</span> <span class="st">&quot;y_pc_d&quot;</span>, <span class="at">level =</span> <span class="st">&quot;i&quot;</span>, <span class="at">ids =</span> <span class="st">&quot;upm&quot;</span>, <span class="at">estrato =</span> <span class="st">&quot;estrato&quot;</span>)</span></code></pre></div>
<p>Para estimar el ingreso medio de los hogares a precios constantes de
enero 2005 según departamento, se debe definir en el argumento by.x la
variable “nomdpto”</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Estimación de ingresos promedio per cápita a pesos constantes de ene/05 según dpto</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">get_estimation_mean</span>(df, <span class="at">variable =</span> <span class="st">&quot;y_pc_d&quot;</span>, <span class="at">by.x =</span> <span class="st">&quot;nomdpto&quot;</span>, <span class="at">level =</span> <span class="st">&quot;i&quot;</span>, <span class="at">ids =</span> <span class="st">&quot;upm&quot;</span>, <span class="at">estrato =</span> <span class="st">&quot;estrato&quot;</span>)</span></code></pre></div>
<!-- Una forma de mostrar estos resultados es mediante un gráfico como el siguiente: -->
<p>Podemos comparar estos resultados con los publicados por el
Observatorio Territorio Uruguay de OPP que se encuentran <a href="https://otu.opp.gub.uy/?q=listados/listados_datos_formato&amp;id=2727&amp;cant=0&amp;fecha=2019-01-01">aquí</a>.</p>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
